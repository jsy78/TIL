# 알고리즘의 시간 복잡도

- 좋은 알고리즘은 무엇일까? 
  - 입력을 넣은 후 출력이 나오는 시간이 짧은 알고리즘!
- 알고리즘 소요 시간 측정
  - 컴퓨팅 환경에 따라 같은 알고리즘이라도 측정 시간이 다름
  - 환경에 영향을 받지 않는 객관적 기준이 필요
  - 객관적 측정을 위해 알고리즘 내부에서 기본 연산(할당, 산술, 비교, 반환 등)이 몇 번 일어나는지 측정
  - 기본 연산의 총 횟수 == 알고리즘의 소요 시간
    - 따라서 성능을 측정할 때는 입력을 통일시켜야 함
- 시간 복잡도란?
  - 문제를 해결하는 데 걸리는 시간과 입력의 함수 관계
  - 요약하자면 알고리즘의 수행 시간을 의미함
  - 시간 복잡도가 높으면 느린 알고리즘, 낮으면 빠른 알고리즘

# Big-O 표기법

- 입력 n이 무한대로 커진다고 가정하고 시간 복잡도를 간단하게 표시하는 것

- 최고차항만 남기고 계수와 상수를 제거함
  - 6n + 4 == O(n)
  - 3n + 2 == O(n)
  - 3n^2 + 6n + 1 => O(n^2)


![big_O](https://lee-jeongmin.github.io/assets/img/big_O.jpg)

| 표기       | 내용                                                         | 1초가 걸리는 입력의 크기<br/>(1억 기준) |
| :--------- | ------------------------------------------------------------ | --------------------------------------- |
| O(1)       | 단순 산술 계산 (덧셈, 뺄셈, 곱셉, 나눗셈)                    | 1억                                     |
| O(log n)   | 크기 N인 리스트를 반절씩 순회 / 탐색<br/>이진 탐색 (Binary Search), 분할 정복 (Divide & Conquer) | 500만                                   |
| O(n)       | 크기 N인 리스트를 순회<br/>단일 for 문                       | -                                       |
| O(n log n) | 크기 N인 리스트를 반절씩 탐색 * 순회<br/>높은 성능의 정렬 (Merge / Quick / Heap Sort) | -                                       |
| O(n^2)     | 크기 M, N인 이중 리스트를 순회<br/>이중 for 문               | 1만                                     |
| O(n^3)     | 삼중 리스트를 순회<br/>삼중 for 문                           | 500                                     |
| O(2^n)     | 크기 N 집합의 부분 집합                                      | 20                                      |
| O(n!)      | 크기 N 리스트의 순열                                         | 10                                      |

```python
# 1부터 n까지 일일이 더하기

# 단일 for 문 사용
def get_total(n):
    total = 0
        for i in range(1, n + 1):
    total += 1
    return total

print(get_total(10))
>>> 55

print(get_total(1000000000))
>>> 제한 시간 1초 초과


# 가우스의 합 공식 사용
# 단순 계산 O(n)
def get_total(n):
    return (n * (n + 1)) // 2

print(get_total(10))
>>> 55

print(get_total(1000000000))
>>> 500000000500000000
```

- 같은 Output을 만드는 알고리즘이라도 시간 복잡도에 따라 성능이 달라질 수 있고 시험에서 정답 여부가 갈릴 수 있음
- 내장 함수, 메소드의 시간 복잡도도 확인할 필요가 있음
  - for문 안에 O(n)의 내장 함수를 사용했다면 사실상 이중 for문과 다를 것이 없기 때문

# 리스트

## 배열 vs 연결 리스트

- 배열
  - 여러 데이터들이 연속된 메모리 공간에 저장되어 있는 자료구조
  - 인덱스를 통해 데이터에 빠르게 접근
  - 배열의 길이는 변경 불가능 
    - 길이를 변경하고 싶다면 새로 생성
  - 데이터 타입은 고정

- 연결 리스트

  - 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조
  - 맨 처음 노드부터 순차적으로 탐색
  - 연결 리스트의 길이 자유롭게 변경 가능 
    - 삽입, 삭제가 편리
  - 다양한 데이터 타입 저장
  - 데이터가 메모리에 연속적으로 저장되지 않음

- 파이썬은 배열의 장점(인덱스 접근)과 연결 리스트의 장점(가변 길이)을 모두 가지고 있음

  | 인덱스 | A[0] | A[1] | A[2]   | A[3] | A[4] |
  | ------ | ---- | ---- | ------ | ---- | ---- |
  | 주소   | 2456 | 3882 | 6428   | 2938 | 8472 |
  | 데이터 | "a"  | 123  | [1, 2] | 1.5  | 0    |

- 파이썬 리스트 관련 메소드

  | 메소드     | 설명                                                         | 표기       |
  | ---------- | ------------------------------------------------------------ | ---------- |
  | .append()  | 리스트 맨 끝에 새로운 원소 삽입                              | O(1)       |
  | .pop()     | 특정 인덱스에 있는 원소를 삭제 및 반환                       | O(1)       |
  | .count()   | 리스트에서 해당 원소의 개수를 반환                           | O(n)       |
  | .index()   | 리스트에서 처음으로 해당 원소가 등장하는 인덱스 반환         | O(n)       |
  | .sort()    | 리스트를 오름차순으로 정렬<br/>reverse = True 옵션을 통해 내림차순으로 정렬 가능 | O(n log n) |
  | .reverse() | 리스트를 원소들의 순서를 거꾸로 뒤집기                       | O(n)       |

- 파이썬 리스트 관련 내장 함수

  | 내장 함수          | 설명                                                         | 표기       |
  | ------------------ | ------------------------------------------------------------ | ---------- |
  | len(iterable)      | 리스트 길이(원소의 개수)를 반환                              | O(1)       |
  | sum(iterable)      | 리스트의 모든 원소의 합 을 반환                              | O(n)       |
  | max(iterable)      | 리스트의 원소 중 최댓값을 반환                               | O(n)       |
  | min(iterable)      | 리스트의 원소 중 최솟값을 반환                               | O(n)       |
  | sorted(iterable)   | 오름차순으로 정렬된 새로운 리스트 반환, 원본 리스트는 변화 없음 | O(n log n) |
  | reversed(iterable) | 리스트의 순서를 거꾸로 뒤집은 새로운 객체 반환, 원본 리스트는 변화 없음 | O(n)       |

