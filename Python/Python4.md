# 데이터 구조

- input().split() : 문자열.split()
- [1, 2, 3].append(4) : 리스트.append(4)
- 타입.**메소드**()

## 메소드

### 시퀀스

- 순서가 있는 데이터 구조

#### 문자열

- 문자들의 나열 (str 타입)

- 문자열은 따옴표를 활용하여 표기

- 문자열 검증

  | 문법              | 설명                                                         |
| ----------------- | ------------------------------------------------------------ |
| **s.find(x)**     | x의 첫 번째 위치를 반환. 없으면 -1을 반환                    |
| **s.index(x)**    | x의 첫 번째 위치를 반환. 없으면 오류 발생                    |
| **s.isalpha()**   | 알파벳 문자 여부(단순 알파벳이 아닌 유니코드 상 문자, 한글도 포함) |
| **s.isupper()**   | 대문자 여부                                                  |
| **s.islower()**   | 소문자 여부                                                  |
| s.istitle()       | 타이틀 형식 여부                                             |
| **s.isdecimal()** | 숫자 여부                                                    |

- 문자열 변경

  | 문법                                                        | 설명                                                         |
  | ----------------------------------------------------------- | ------------------------------------------------------------ |
  | **s.replace(old, new[,count])**                             | 바꿀 대상 글자를 새로운 글자로 바꿔서 반환, count를 지정하면 해당 개수만큼만 시행 |
  | **s.strip([chars])**, s.lstrip([chars]) , s.rstrip([chars]) | 특정한 문자들을 지정하면 양쪽을 제거하거나(strip), 왼쪽을 제거하거나(lstrip), 오른쪽을 제거(rstrip), 지정하지 않으면 공백 제거 |
  | **s.split(sep=None, maxsplit=-1)**                          | 공백이나 특정 문자를 기준으로 분리하여 리스트로 반환, maxsplit이 -1인 경우에는 제한이 없음 |
  | **'separator'.join([iterable])**                            | 반복 가능한(iterable) 컨테이너 요소들을 separator(구분자)로 합쳐 문자열 반환, iterable에 문자열이 아닌 값이 있으면 TypeError 발생 |
  | s.capitalize()                                              | 첫 글자를 대문자로, 나머지 글자를 소문자로 변경              |
  | s.title()                                                   | 문자열을 타이틀 형식으로 변경 ('나 공백 이후를 대문자로 변경) |
  | **s.upper()**                                               | 모든 글자를 대문자로 변경                                    |
  | **s.lower()**                                               | 모든 글자를 소문자로 변경                                    |
  | **s.swapcase()**                                            | 대소문자를 서로 변경                                         |

#### 리스트

- 변경 가능한 값들이 나열된 자료형

- 순서를 가지며, 서로 다른 타입의 요소를 가질 수 있음

- 변경 가능하며 반복 가능함

- 항상 대괄호 형태로 정의하며 각 요소는 콤마로 구분

- 리스트 조작

  | 문법                   | 설명                                                         |
  | ---------------------- | ------------------------------------------------------------ |
  | **L.append(x)**        | 리스트 마지막에 항목 x를 추가                                |
  | **L.insert(i, x)**     | 리스트 인덱스 i에 항목 x를 삽입, i가 리스트 길이보다 클 경우엔 리스트 맨 뒤에 삽입 |
  | L.remove(x)            | 리스트 가장 왼쪽에 있는 항목(첫 번째) x를 제거, 항목이 존재하지 않을 경우 ValueError |
  | L.pop()                | 리스트 가장 오른쪽에 있는 항목(마지막)을 반환 후 제거        |
  | L.pop(i)               | 리스트의 인덱스 i에 있는 항목을 반환 후 제거                 |
  | **L.extend(m)**        | 순회형 m의 모든 항목들을 리스트 끝에 추가 (+=과 같은 기능)   |
  | L.index(x, start, end) | 리스트에 있는 항목 중 가장 왼쪽에 있는 항목 x의 인덱스를 반환, start와 end로 탐색 범위 지정 |
  | L.reverse()            | 리스트에 있는 모든 요소의 순서를 반대로 뒤집고 None 반환(정렬이 아님!) |
  | **L.sort()**           | 리스트를 정렬 (매개변수 이용가능)하고 None을 반환 (sorted 함수와 헷갈리지 말 것) |
  | **L.count(x)**         | 리스트에서 항목 x가 몇 개 존재하는지 갯수를 반환             |
  | L.clear()              | 리스트의 모든 항목 삭제                                      |

### 컬렉션

- 순서가 없는 데이터 구조

#### 세트

- 유일한 값들의 모음

- 순서가 없고 중복된 값도 없음

- 변경 가능하며 반복 가능함

- 세트 조작 (그냥 이런 게 있다 정도로만)

  | 문법            | 설명                                                         |
  | --------------- | ------------------------------------------------------------ |
  | s.copy()        | 세트의 얕은 복사본을 반환 (얕은 복사와 깊은 복사의 차이는 다음에) |
  | s.add(x)        | 항목 x가 세트 s에 없다면 추가                                |
  | s.pop()         | 세트 s에서 무작위로 항목을 반환하고 해당 항목을 제거, 세트가 비어 있을 경우 KeyError |
  | s.remove(x)     | 항목 x를 세트 s에서 삭제, 항목이 존재하지 않을 경우 KeyError |
  | s.discard(x)    | 항목 x가 세트 s에 있는 경우, 항목 x를 세트 s에서 삭제        |
  | s.update(t)     | 세트 t에 있는 모든 항목 중 세트 s에 없는 항목을 추가         |
  | s.clear()       | 세트 s의 모든 항목을 제거                                    |
  | s.isdisjoint(t) | 세트 s와 세트 t가 서로소일 경우 True 반환                    |
  | s.issubset(t)   | 세트 s가 세트 t의 하위 세트인 경우, True 반환                |
  | s.issuperset(t) | 세트 s가 세트 t의 상위 세트인 경우, True 반환                |

#### 딕셔너리

- 키-값 쌍으로 이루어진 모음

  - 키 : 불변 자료형만 가능(리스트, 딕셔너리 등은 불가능함)
  - 값 : 어떠한 형태든 관계 없음

- 키와 값은 (:)로 구분되고 개별 요소는 (,)로 구분됨

- 변경 가능하며 반복 가능함

  - 딕셔너리는 반복하면 키가 반환됨

- 딕셔너리 조작

  | 문법              | 설명                                                         |
  | ----------------- | ------------------------------------------------------------ |
  | d.clear()         | 모든 항목을 제거                                             |
  | **d.keys()**      | 딕셔너리 d의 모든 키를 담은 뷰를 반환                        |
  | **d.values()**    | 딕셔너리 d의 모든 값을 담은 뷰를 반환                        |
  | **d.items()**     | 딕셔너리 d의 모든 키-값 튜플 쌍을 담은 뷰를 반환             |
  | **d.get(k)**      | 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 None을 반환 |
  | **d.get(k, v)**   | 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 v을 반환 |
  | d.pop(k)          | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 KeyError를 발생 |
  | d.pop(k, v)       | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 v를 반환 |
  | d.update([other]) | 딕셔너리 d의 값을 매핑하여 업데이트 (딕셔너리 d의 값을 other에서 제공하는 key, value로 덮어씀) |

  
